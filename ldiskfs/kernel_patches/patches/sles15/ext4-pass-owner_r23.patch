diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 0ae13df..2d24e57 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -2712,6 +2712,7 @@ extern int ext4_orphan_add(handle_t *, struct inode *);
 extern int ext4_orphan_del(handle_t *, struct inode *);
 extern struct inode *ext4_create_inode(handle_t *handle,
 				       struct inode *dir, int mode,
+				       uid_t *owner,
 				       struct iattr *iattr);
 extern int ext4_delete_entry(handle_t *handle, struct inode * dir,
 			     struct ext4_dir_entry_2 *de_del,
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index a126b29..c6b93ba 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -3041,18 +3041,21 @@ static int ext4_add_nondir(handle_t *handle,
  /* Return locked inode, then the caller can modify the inode's states/flags
   * before others finding it. The caller should unlock the inode by itself. */
 struct inode *ext4_create_inode(handle_t *handle, struct inode *dir, int mode,
-				struct iattr *iattr)
+				uid_t *owner, struct iattr *iattr)
 {
 	struct inode *inode;
-	uid_t owner[2];
+	uid_t _owner[2];
 
-	if (iattr) {
-		owner[0] = from_kuid(&init_user_ns, iattr->ia_uid);
-		owner[1] = from_kgid(&init_user_ns, iattr->ia_gid);
+	if (!owner && iattr) {
+		owner = _owner;
+		if (iattr->ia_valid & ATTR_UID)
+			owner[0] = from_kuid(&init_user_ns, iattr->ia_uid);
+		if (iattr->ia_valid & ATTR_GID)
+			owner[1] = from_kgid(&init_user_ns, iattr->ia_gid);
 	}
 
-	inode = __ext4_new_inode(handle, dir, mode, NULL, 0,
-				    iattr ? owner : NULL, 0, 0, 0, iattr);
+	inode = __ext4_new_inode(handle, dir, mode, NULL, 0, owner,
+				 0, 0, 0, iattr);
 	if (!IS_ERR(inode)) {
 		if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode)) {
 #ifdef CONFIG_LDISKFS_FS_XATTR
