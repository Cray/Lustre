--- linux1/fs/ext4/ialloc.c
+++ linux2/fs/ext4/ialloc.c
@@ -708,7 +708,8 @@ next:
 struct inode *__ext4_new_inode(handle_t *handle, struct inode *dir,
 			       umode_t mode, const struct qstr *qstr,
 			       __u32 goal, uid_t *owner, int handle_type,
-			       unsigned int line_no, int nblocks)
+			       unsigned int line_no, int nblocks,
+			       struct iattr *iattr)
 {
 	struct super_block *sb;
 	struct buffer_head *inode_bitmap_bh = NULL;
@@ -980,8 +981,14 @@ got:
 	inode->i_ino = ino + group * EXT4_INODES_PER_GROUP(sb);
 	/* This is the optimal IO size (for stat), not the fs block size */
 	inode->i_blocks = 0;
-	inode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =
-						       ext4_current_time(inode);
+
+	ei->i_crtime = ext4_current_time(inode);
+	inode->i_mtime = iattr && iattr->ia_mtime.tv_nsec != UTIME_OMIT ?
+			 iattr->ia_mtime : ei->i_crtime;
+	inode->i_atime = iattr && iattr->ia_atime.tv_nsec != UTIME_OMIT ?
+			 iattr->ia_atime : ei->i_crtime;
+	inode->i_ctime = iattr && iattr->ia_ctime.tv_nsec != UTIME_OMIT ?
+			 iattr->ia_ctime : ei->i_crtime;
 
 	memset(ei->i_data, 0, sizeof(ei->i_data));
 	ei->i_dir_start_lookup = 0;
--- linux1/fs/ext4/ext4.h
+++ linux2/fs/ext4/ext4.h
@@ -2335,15 +2335,16 @@ extern int ext4fs_dirhash(const char *na
 extern struct inode *__ext4_new_inode(handle_t *, struct inode *, umode_t,
 				      const struct qstr *qstr, __u32 goal,
 				      uid_t *owner, int handle_type,
-				      unsigned int line_no, int nblocks);
+				      unsigned int line_no, int nblocks,
+				      struct iattr *iattr);
 
 #define ext4_new_inode(handle, dir, mode, qstr, goal, owner) \
 	__ext4_new_inode((handle), (dir), (mode), (qstr), (goal), (owner), \
-			 0, 0, 0)
+			 0, 0, 0, NULL)
 #define ext4_new_inode_start_handle(dir, mode, qstr, goal, owner, \
 				    type, nblocks)		    \
 	__ext4_new_inode(NULL, (dir), (mode), (qstr), (goal), (owner), \
-			 (type), __LINE__, (nblocks))
+			 (type), __LINE__, (nblocks), NULL)
 
 
 extern void ext4_free_inode(handle_t *, struct inode *);
@@ -2470,7 +2471,8 @@ extern int ext4_orphan_del(handle_t *, s
 extern int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,
 				__u32 start_minor_hash, __u32 *next_hash);
 extern struct inode *ext4_create_inode(handle_t *handle,
-				       struct inode *dir, int mode);
+				       struct inode *dir, int mode,
+				       struct iattr *iattr);
 extern int ext4_delete_entry(handle_t *handle, struct inode * dir,
 			     struct ext4_dir_entry_2 *de_del,
 			     struct buffer_head *bh);
--- linux1/fs/ext4/namei.c
+++ linux2/fs/ext4/namei.c
@@ -2880,11 +2880,19 @@ static int ext4_add_nondir(handle_t *han
 
  /* Return locked inode, then the caller can modify the inode's states/flags
   * before others finding it. The caller should unlock the inode by itself. */
-struct inode *ext4_create_inode(handle_t *handle, struct inode *dir, int mode)
+struct inode *ext4_create_inode(handle_t *handle, struct inode *dir, int mode,
+				struct iattr *iattr)
 {
 	struct inode *inode;
+	uid_t owner[2];
 
-	inode = ext4_new_inode(handle, dir, mode, NULL, 0, NULL);
+	if (iattr) {
+		owner[0] = from_kuid(&init_user_ns, iattr->ia_uid);
+		owner[1] = from_kgid(&init_user_ns, iattr->ia_gid);
+	}
+
+	inode = __ext4_new_inode(handle, dir, mode, NULL, 0,
+				    iattr ? owner : NULL, 0, 0, 0, iattr);
 	if (!IS_ERR(inode)) {
 		if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode)) {
 #ifdef CONFIG_LDISKFS_FS_XATTR
